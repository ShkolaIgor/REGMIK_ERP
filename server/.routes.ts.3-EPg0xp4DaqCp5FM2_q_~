import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./db-storage";
import { registerSimpleIntegrationRoutes } from "./integrations-simple";
import { registerSyncApiRoutes } from "./sync-api";
import { sendCompanyDataToERP, sendInvoiceToERP, syncAllCompaniesFromBitrix, syncAllInvoicesFromBitrix, sendCompanyDataToERPWebhook, sendInvoiceToERPWebhook } from "./bitrix-sync";
import { analyzeOrderProduction } from "./ai-production-service";
import { generateMassProductionPlan, createProductionTasksFromPlan } from "./ai-mass-production-service";
import { setupSimpleSession, setupSimpleAuth, isSimpleAuthenticated } from "./simple-auth";
import { novaPoshtaApi } from "./nova-poshta-api";
import { novaPoshtaCache } from "./nova-poshta-cache";
import { pool, db } from "./db";
import { eq, sql, and, isNotNull } from "drizzle-orm";
import { productComponents, components, productNameMappings } from "@shared/schema";
import { 
  insertProductSchema, insertOrderSchemaForm, insertRecipeSchema,
  insertProductionTaskSchema, insertCategorySchema, insertUnitSchema, insertWarehouseSchema,
  insertSupplierSchema, insertInventorySchema, insertTechCardSchema, insertTechCardStepSchema, insertTechCardMaterialSchema,
  insertComponentSchema, insertProductComponentSchema, insertCostCalculationSchema, insertMaterialShortageSchema,
  insertAssemblyOperationSchema, insertAssemblyOperationItemSchema,
  insertInventoryAuditSchema, insertInventoryAuditItemSchema,
  insertWorkerSchema, insertProductionForecastSchema,
  insertWarehouseTransferSchema, insertPositionSchema, insertDepartmentSchema,
  insertPackageTypeSchema, insertSolderingTypeSchema, insertComponentAlternativeSchema, insertComponentCategorySchema,
  insertShipmentSchema, insertManufacturingOrderSchema, insertManufacturingOrderMaterialSchema, insertManufacturingStepSchema,
  insertCurrencySchema, insertSerialNumberSchema, insertSerialNumberSettingsSchema,
  insertLocalUserSchema, insertRoleSchema, insertSystemModuleSchema, changePasswordSchema,
  insertEmailSettingsSchema, insertClientSchema, insertClientContactSchema, insertClientMailSchema, insertMailRegistrySchema, insertEnvelopePrintSettingsSchema,
  insertRepairSchema, insertRepairPartSchema, insertRepairStatusHistorySchema, insertRepairDocumentSchema,
  clientTypes, insertClientTypeSchema, insertOrderStatusSchema, orders
} from "@shared/schema";
import bcrypt from "bcryptjs";
import { z } from "zod";
import crypto from "crypto";
import { sendEmail } from "./email-service";
import { bankEmailService } from "./bank-email-service";
import multer from "multer";
import xml2js from "xml2js";
import { DOMParser } from "@xmldom/xmldom";

// Helper function for fallback outgoing invoices data when 1C server is unavailable
async function getFallbackOutgoingInvoices() {
  try {
    const existingOrders = await storage.getOrders();
    const importedSet = new Set(
      existingOrders
        .filter(order => order.invoiceNumber)
        .map(order => order.invoiceNumber)
    );

    const fallbackData = [
      {
        id: "fallback-out-1",
        number: "–†–ú00-027688",
        date: "2025-01-15",
        clientName: "–í–Ü–ö–û–†–î –¢–û–í",
        clientTaxCode: "12345678",
        total: 15000.00,
        currency: "UAH",
        status: "confirmed",
        paymentStatus: "paid",
        description: "Fallback —Ç–µ—Å—Ç–æ–≤–∏–π —Ä–∞—Ö—É–Ω–æ–∫ 1",
        managerName: "–ú–µ–Ω–µ–¥–∂–µ—Ä 1",
        positions: [
          {
            productName: "–¢–°–ü-002",
            quantity: 5,
            price: 1500.00,
            total: 7500.00
          },
          {
            productName: "–†–ü2-–£-110",
            quantity: 2,
            price: 3750.00,
            total: 7500.00
          }
        ],
        itemsCount: 2,
        exists: importedSet.has("–†–ú00-027688")
      },
      {
        id: "fallback-out-2", 
        number: "–†–ú00-027687",
        date: "2025-01-14",
        clientName: "–£–ö–†–ï–ù–ï–†–ì–û –ù–ï–ö",
        clientTaxCode: "87654321",
        total: 8500.00,
        currency: "UAH",
        status: "confirmed",
        paymentStatus: "unpaid",
        description: "Fallback —Ç–µ—Å—Ç–æ–≤–∏–π —Ä–∞—Ö—É–Ω–æ–∫ 2",
        managerName: "–ú–µ–Ω–µ–¥–∂–µ—Ä 2",
        positions: [
          {
            productName: "–¢–°–ü-205",
            quantity: 1,
            price: 8500.00,
            total: 8500.00
          }
        ],
        itemsCount: 1,
        exists: importedSet.has("–†–ú00-027687")
      }
    ];

    console.log('üìã FALLBACK OUTGOING INVOICES: –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ —Ç–µ—Å—Ç–æ–≤—ñ –¥–∞–Ω—ñ –∑ exists property');
    return fallbackData;
  } catch (error) {
    console.error('–ü–æ–º–∏–ª–∫–∞ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è fallback –¥–∞–Ω–∏—Ö:', error);
    return [];
  }
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Simple auth setup
  setupSimpleSession(app);
  setupSimpleAuth(app);

  // Multer configuration for file uploads
  const upload = multer({
    storage: multer.memoryStorage(),
    limits: {
      fileSize: 100 * 1024 * 1024, // 100MB limit –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö XML —Ñ–∞–π–ª—ñ–≤
    },
    fileFilter: (req, file, cb) => {
      if (file.mimetype === 'text/xml' || file.originalname.endsWith('.xml')) {
        cb(null, true);
      } else {
        cb(new Error('Only XML files are allowed'));
      }
    },
  });

  // Multer configuration for logo uploads
  const logoUpload = multer({
    storage: multer.memoryStorage(),
    limits: {
      fileSize: 5 * 1024 * 1024, // 5MB limit for images
    },
    fileFilter: (req, file, cb) => {
      if (file.mimetype.startsWith('image/')) {
        cb(null, true);
      } else {
        cb(new Error('Only image files are allowed'));
      }
    },
  });

  // –í–Ü–î–ö–õ–Æ–ß–ï–ù–û: Register simple integration routes (–∫–æ–Ω—Ñ–ª—ñ–∫—Ç—É—î –∑ –ë–î –º–∞—Ä—à—Ä—É—Ç–∞–º–∏)
  // registerSimpleIntegrationRoutes(app);
  
  // Register sync API routes
  registerSyncApiRoutes(app);

  // Dashboard stats
  app.get("/api/dashboard/stats", async (req, res) => {
    try {
      const stats = await storage.getDashboardStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch dashboard stats" });
    }
  });

  // Analytics API
  app.get("/api/analytics/sales", isSimpleAuthenticated, async (req, res) => {
    try {
      const { period = 'month' } = req.query;
      const salesData = await storage.getSalesAnalytics(period as string);
      res.json(salesData);
    } catch (error) {
      console.error("Error fetching sales analytics:", error);
      res.status(500).json({ error: "Failed to fetch sales analytics" });
    }
  });

  app.get("/api/analytics/expenses", isSimpleAuthenticated, async (req, res) => {
    try {
      const { period = 'month' } = req.query;
      const expensesData = await storage.getExpensesAnalytics(period as string);
      res.json(expensesData);
    } catch (error) {
      console.error("Error fetching expenses analytics:", error);
      res.status(500).json({ error: "Failed to fetch expenses analytics" });
    }
  });

  app.get("/api/analytics/profit", isSimpleAuthenticated, async (req, res) => {
    try {
      const { period = 'month' } = req.query;
      const profitData = await storage.getProfitAnalytics(period as string);
      res.json(profitData);
    } catch (error) {
      console.error("Error fetching profit analytics:", error);
      res.status(500).json({ error: "Failed to fetch profit analytics" });
    }
  });

  // Product profitability analysis
  app.get("/api/analytics/product-profitability", isSimpleAuthenticated, async (req, res) => {
    try {
      const { period = 'month' } = req.query;
      const profitabilityData = await storage.getProductProfitability();
      res.json(profitabilityData);
    } catch (error) {
      console.error("Error fetching product profitability:", error);
      res.status(500).json({ error: "Failed to fetch product profitability" });
    }
  });

  app.get("/api/analytics/top-profitable-products", isSimpleAuthenticated, async (req, res) => {
    try {
      const { limit = '10', period = 'month' } = req.query;
      const topProducts = await storage.getTopProfitableProducts(parseInt(limit as string), period as string);
      res.json(topProducts);
    } catch (error) {
      console.error("Error fetching top profitable products:", error);
      res.status(500).json({ error: "Failed to fetch top profitable products" });
    }
  });

  app.get("/api/analytics/product-trends/:productId", isSimpleAuthenticated, async (req, res) => {
    try {
      const { productId } = req.params;
      const { months = '6' } = req.query;
      const trends = await storage.getProductProfitabilityTrends(parseInt(productId), parseInt(months as string));
      res.json(trends);
    } catch (error) {
      console.error("Error fetching product trends:", error);
      res.status(500).json({ error: "Failed to fetch product trends" });
    }
  });

  // Time tracking API
  app.get("/api/time-entries", isSimpleAuthenticated, async (req, res) => {
    try {
      const timeEntries = await storage.getTimeEntries();
      res.json(timeEntries);
    } catch (error) {
      console.error("Error fetching time entries:", error);
      res.status(500).json({ error: "Failed to fetch time entries" });
    }
  });

  app.post("/api/time-entries", isSimpleAuthenticated, async (req, res) => {
    try {
      const timeEntryData = req.body;
      const timeEntry = await storage.createTimeEntry(timeEntryData);
      res.status(201).json(timeEntry);
    } catch (error) {
      console.error("Error creating time entry:", error);
      res.status(500).json({ error: "Failed to create time entry" });
    }
  });

  app.patch("/api/time-entries/:id", isSimpleAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateData = req.body;
      const timeEntry = await storage.updateTimeEntry(id, updateData);
      res.json(timeEntry);
    } catch (error) {
      console.error("Error updating time entry:", error);
      res.status(500).json({ error: "Failed to update time entry" });
    }
  });

  // Inventory alerts API
  app.get("/api/inventory/alerts", isSimpleAuthenticated, async (req, res) => {
    try {
      const alerts = await storage.getInventoryAlerts();
      res.json(alerts);
    } catch (error) {
      console.error("Error fetching inventory alerts:", error);
      res.status(500).json({ error: "Failed to fetch inventory alerts" });
    }
  });

  app.post("/api/inventory/check-alerts", isSimpleAuthenticated, async (req, res) => {
    try {
      await storage.checkAndCreateInventoryAlerts();
      res.json({ message: "Inventory alerts checked and updated" });
    } catch (error) {
      console.error("Error checking inventory alerts:", error);
      res.status(500).json({ error: "Failed to check inventory alerts" });
    }
  });

  // Password reset functionality
  app.post("/api/auth/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ message: "Email —î –æ–±–æ–≤'—è–∑–∫–æ–≤–∏–º" });
      }

      // –ó–Ω–∞–π—Ç–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑–∞ email
      const user = await storage.getUserByEmail(email);
      if (!user) {
        // –ù–µ –ø–æ–∫–∞–∑—É—î–º–æ, —â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ —ñ—Å–Ω—É—î –∑ –º—ñ—Ä–∫—É–≤–∞–Ω—å –±–µ–∑–ø–µ–∫–∏
        return res.json({ message: "–Ø–∫—â–æ email —ñ—Å–Ω—É—î –≤ —Å–∏—Å—Ç–µ–º—ñ, –ª–∏—Å—Ç –±—É–¥–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ" });
      }

      // –ì–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ —Ç–æ–∫–µ–Ω —Å–∫–∏–¥–∞–Ω–Ω—è –ø–∞—Ä–æ–ª—é
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetExpires = new Date(Date.now() + 3600000); // 1 –≥–æ–¥–∏–Ω–∞

      // –ó–±–µ—Ä–µ–≥—Ç–∏ —Ç–æ–∫–µ–Ω –≤ –±–∞–∑—ñ –¥–∞–Ω–∏—Ö
      const tokenSaved = await storage.savePasswordResetToken(user.id, resetToken, resetExpires);
      
      if (!tokenSaved) {
        return res.status(500).json({ message: "–ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ç–æ–∫–µ–Ω—É" });
      }

      // –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–∑–æ–≤—É URL –∑ –∑–∞–≥–æ–ª–æ–≤–∫—ñ–≤
      const protocol = req.get('x-forwarded-proto') || req.protocol || 'https';
      const host = req.get('host') || req.get('x-forwarded-host');
      
      // –í–∏–ø—Ä–∞–≤–ª—è—î–º–æ —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è URL - –≤–∏–¥–∞–ª—è—î–º–æ –∑–∞–π–≤—ñ —Å–ª–µ—à—ñ
      let baseUrl = `${protocol}://${host}`;
      if (baseUrl.includes('\\')) {
        baseUrl = baseUrl.replace(/\\/g, '');
      }
      
      const resetUrl = `${baseUrl}/reset-password?token=${resetToken}`;
      
      console.log("Protocol:", protocol);
      console.log("Host:", host);
      console.log("Base URL:", baseUrl);
      console.log("Generated reset URL:", resetUrl);

      // –í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ email —á–µ—Ä–µ–∑ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–∏–π —Å–µ—Ä–≤—ñ—Å
      console.log("Attempting to send email to:", email);
      
      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è email
      const emailSettings = await storage.getEmailSettings();
      console.log("Email settings loaded:", emailSettings ? "Yes" : "No");
      
      if (!emailSettings || !emailSettings.smtpHost) {
        console.log("Email service not configured or inactive");
        return res.status(500).json({ message: "–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ email - —Å–µ—Ä–≤—ñ—Å –Ω–µ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–∏–π" });
      }
      
      // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ nodemailer –Ω–∞–ø—Ä—è–º—É –∑ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è–º–∏
      const nodemailer = await import('nodemailer');
      const transportConfig = {
        host: emailSettings.smtpHost,
        port: emailSettings.smtpPort || 587,
        secure: emailSettings.smtpSecure || false,
        auth: {
          user: emailSettings.smtpUser,
          pass: emailSettings.smtpPassword,
        },
      };
      const transporter = nodemailer.createTransport(transportConfig as any);

      try {
        const emailResult = await transporter.sendMail({
          from: emailSettings.fromEmail || "noreply@regmik-erp.com",
          to: email,
          subject: "–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–∞—Ä–æ–ª—é - REGMIK ERP",
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <h1 style="color: #2563eb; margin: 0; text-align: center;">REGMIK: ERP</h1>
                <p style="color: #6b7280; margin: 5px 0 0 0; text-align: center;">–°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –≤–∏—Ä–æ–±–Ω–∏—Ü—Ç–≤–æ–º</p>
              </div>
              
              <h2 style="color: #374151;">–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–∞—Ä–æ–ª—é</h2>
              
              <p style="color: #6b7280; line-height: 1.6;">
                –í–∏ –æ—Ç—Ä–∏–º–∞–ª–∏ —Ü–µ–π –ª–∏—Å—Ç, –æ—Å–∫—ñ–ª—å–∫–∏ –¥–ª—è –≤–∞—à–æ–≥–æ –æ–±–ª—ñ–∫–æ–≤–æ–≥–æ –∑–∞–ø–∏—Å—É –±—É–≤ –∑–∞–ø–∏—Ç–∞–Ω–∏–π —Å–∫–∏–¥–∞–Ω–Ω—è –ø–∞—Ä–æ–ª—é.
              </p>
              
              <p style="color: #6b7280; line-height: 1.6;">
                –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂—á–µ, —â–æ–± –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ –Ω–æ–≤–∏–π –ø–∞—Ä–æ–ª—å:
              </p>
              
              <div style="text-align: center; margin: 30px 0;">
                <a href="${resetUrl}" style="background: #2563eb; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                  –í—ñ–¥–Ω–æ–≤–∏—Ç–∏ –ø–∞—Ä–æ–ª—å
                </a>
              </div>
              
              <p style="color: #6b7280; line-height: 1.6; font-size: 14px;">
                –Ø–∫—â–æ –∫–Ω–æ–ø–∫–∞ –Ω–µ –ø—Ä–∞—Ü—é—î, —Å–∫–æ–ø—ñ—é–π—Ç–µ —Ç–∞ –≤—Å—Ç–∞–≤—Ç–µ —Ü–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è —É –≤–∞—à –±—Ä–∞—É–∑–µ—Ä:
              </p>
              <p style="color: #2563eb; word-break: break-all; font-size: 14px;">
                ${resetUrl}
              </p>
              
              <p style="color: #6b7280; line-height: 1.6; font-size: 14px;">
                –¶–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –¥—ñ–π—Å–Ω–µ –ø—Ä–æ—Ç—è–≥–æ–º 1 –≥–æ–¥–∏–Ω–∏. –Ø–∫—â–æ –≤–∏ –Ω–µ –∑–∞–ø–∏—Ç—É–≤–∞–ª–∏ —Å–∫–∏–¥–∞–Ω–Ω—è –ø–∞—Ä–æ–ª—é, –ø—Ä–æ—ñ–≥–Ω–æ—Ä—É–π—Ç–µ —Ü–µ–π –ª–∏—Å—Ç.
              </p>
              
              <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 30px 0;">
              
              <p style="color: #9ca3af; font-size: 12px; text-align: center;">
                REGMIK ERP - –°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –≤–∏—Ä–æ–±–Ω–∏—Ü—Ç–≤–æ–º
              </p>
            </div>
          `
        });
        
        console.log("Email sent successfully:", emailResult.messageId);
      } catch (emailError) {
        console.error("Failed to send email:", emailError);
        return res.status(500).json({ message: "–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ email - –ø–µ—Ä–µ–≤—ñ—Ä—Ç–µ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è SMTP" });
      }

      res.json({ message: "–Ø–∫—â–æ email —ñ—Å–Ω—É—î –≤ —Å–∏—Å—Ç–µ–º—ñ, –ª–∏—Å—Ç –±—É–¥–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ" });
    } catch (error) {
      console.error("Error in forgot password:", error);
      res.status(500).json({ message: "–í–Ω—É—Ç—Ä—ñ—à–Ω—è –ø–æ–º–∏–ª–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
    }
  });

  // Validate reset token
  app.get("/api/auth/validate-reset-token", async (req, res) => {
    try {
      const { token } = req.query;
      
      if (!token) {
        return res.status(400).json({ message: "–¢–æ–∫–µ–Ω —î –æ–±–æ–≤'—è–∑–∫–æ–≤–∏–º" });
      }

      const user = await storage.getUserByResetToken(token as string);
      
      if (!user) {
        return res.status(400).json({ message: "–ù–µ–¥—ñ–π—Å–Ω–∏–π –∞–±–æ –∑–∞—Å—Ç–∞—Ä—ñ–ª–∏–π —Ç–æ–∫–µ–Ω" });
      }

      res.json({ message: "–¢–æ–∫–µ–Ω –¥—ñ–π—Å–Ω–∏–π" });
    } catch (error) {
      console.error("Error validating reset token:", error);
      res.status(500).json({ message: "–í–Ω—É—Ç—Ä—ñ—à–Ω—è –ø–æ–º–∏–ª–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
    }
  });

  // Reset password with token
  app.post("/api/auth/reset-password", async (req, res) => {
    try {
      const { token, password } = req.body;
      
      if (!token || !password) {
        return res.status(400).json({ message: "–¢–æ–∫–µ–Ω —Ç–∞ –ø–∞—Ä–æ–ª—å —î –æ–±–æ–≤'—è–∑–∫–æ–≤–∏–º–∏" });
      }

      if (password.length < 6) {
        return res.status(400).json({ message: "–ü–∞—Ä–æ–ª—å –ø–æ–≤–∏–Ω–µ–Ω –º—ñ—Å—Ç–∏—Ç–∏ –º—ñ–Ω—ñ–º—É–º 6 —Å–∏–º–≤–æ–ª—ñ–≤" });
      }

      console.log("Looking for user with reset token:", token);
      const user = await storage.getUserByResetToken(token);
      console.log("User found by reset token:", user ? `ID ${user.id}` : "None");
      
      if (!user) {
        return res.status(400).json({ message: "–ù–µ–¥—ñ–π—Å–Ω–∏–π –∞–±–æ –∑–∞—Å—Ç–∞—Ä—ñ–ª–∏–π —Ç–æ–∫–µ–Ω" });
      }

      // –•–µ—à—É–≤–∞—Ç–∏ –Ω–æ–≤–∏–π –ø–∞—Ä–æ–ª—å
      const hashedPassword = await bcrypt.hash(password, 10);
      console.log("Password hashed, updating for user ID:", user.id);

      // –û–Ω–æ–≤–∏—Ç–∏ –ø–∞—Ä–æ–ª—å —Ç–∞ –æ—á–∏—Å—Ç–∏—Ç–∏ —Ç–æ–∫–µ–Ω —Å–∫–∏–¥–∞–Ω–Ω—è
      const success = await storage.confirmPasswordReset(user.id, hashedPassword);
      console.log("Password reset result:", success);
      
      if (!success) {
        return res.status(500).json({ message: "–ü–æ–º–∏–ª–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–∞—Ä–æ–ª—é" });
      }

      res.json({ message: "–ü–∞—Ä–æ–ª—å —É—Å–ø—ñ—à–Ω–æ –æ–Ω–æ–≤–ª–µ–Ω–æ" });
    } catch (error) {
      console.error("Error resetting password:", error);
      res.status(500).json({ message: "–í–Ω—É—Ç—Ä—ñ—à–Ω—è –ø–æ–º–∏–ª–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
    }
  });

  // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—Ä–æ—Ñ—ñ–ª—é –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
  app.patch("/api/auth/profile", isSimpleAuthenticated, async (req, res) => {
    try {
      const sessionUser = (req.session as any)?.user;
      if (!sessionUser?.id) {
        return res.status(401).json({ message: "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–∏–π" });
      }

      const { firstName, lastName, email, profileImageUrl } = req.body;
      const userId = parseInt(sessionUser.id);
      
      // –û—Ç—Ä–∏–º—É—î–º–æ –ø–æ–≤–Ω—ñ –¥–∞–Ω—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
      const fullUser = await storage.getLocalUserWithWorker(userId);
      
      // –û–Ω–æ–≤–ª—é—î–º–æ –¥–∞–Ω—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
      await storage.updateLocalUser(userId, {
        firstName,
        lastName,
        email,
        profileImageUrl,
        updatedAt: new Date()
      });

      // –Ø–∫—â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –ø–æ–≤'—è–∑–∞–Ω–∏–π –∑ —Ä–æ–±—ñ—Ç–Ω–∏–∫–æ–º, –æ–Ω–æ–≤–ª—é—î–º–æ –¥–∞–Ω—ñ —Ä–æ–±—ñ—Ç–Ω–∏–∫–∞
      if (fullUser?.workerId) {
        await storage.updateWorker(fullUser.workerId, {
          firstName,
          lastName,
          email,
          photo: profileImageUrl
        });
      }

      // –û–Ω–æ–≤–ª—é—î–º–æ –¥–∞–Ω—ñ –≤ —Å–µ—Å—ñ—ó
      if (req.session) {
        (req.session as any).user = {
          ...(req.session as any).user,
          firstName,
          lastName,
          email,
          profileImageUrl
        };
      }

      res.json({ message: "–ü—Ä–æ—Ñ—ñ–ª—å —É—Å–ø—ñ—à–Ω–æ –æ–Ω–æ–≤–ª–µ–Ω–æ" });
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—ñ –ø—Ä–æ—Ñ—ñ–ª—é" });
    }
  });

  // Production statistics by category
  app.get("/api/production-stats/by-category", isSimpleAuthenticated, async (req, res) => {
    try {
      const stats = await storage.getProductionStatsByCategory();
      res.json(stats);
    } catch (error) {
      console.error("Error fetching production stats by category:", error);
      res.status(500).json({ error: "Failed to fetch production stats by category" });
    }
  });

  // Order statistics by period
  app.get("/api/production-stats/by-period", isSimpleAuthenticated, async (req, res) => {
    try {
      const { period = 'month', startDate, endDate } = req.query;
      const stats = await storage.getOrderStatsByPeriod(
        period as string, 
        startDate as string, 
        endDate as string
      );
      res.json(stats);
    } catch (error) {
      console.error("Error fetching order stats by period:", error);
      res.status(500).json({ error: "Failed to fetch order stats by period" });
    }
  });

  // Categories
  app.get("/api/categories", async (req, res) => {
    try {
      const categories = await storage.getCategories();
      res.json(categories);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch categories" });
    }
  });

  app.post("/api/categories", async (req, res) => {
    try {
      const categoryData = insertCategorySchema.parse(req.body);
      const category = await storage.createCategory(categoryData);
      res.status(201).json(category);
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid category data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to create category" });
      }
    }
  });

  app.patch("/api/categories/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const categoryData = insertCategorySchema.partial().parse(req.body);
      const category = await storage.updateCategory(id, categoryData);
      if (!category) {
        res.status(404).json({ error: "Category not found" });
        return;
      }
      res.json(category);
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid category data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to update category" });
      }
    }
  });

  app.put("/api/categories/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`PUT /api/categories/${id} received data:`, req.body);
      const categoryData = insertCategorySchema.partial().parse(req.body);
      console.log(`Parsed category data:`, categoryData);
      const category = await storage.updateCategory(id, categoryData);
      if (!category) {
        console.log(`Category with ID ${id} not found`);
        res.status(404).json({ error: "Category not found" });
        return;
      }
      console.log(`Category updated successfully:`, category);
      res.json(category);
    } catch (error) {
      console.error(`Error updating category ${id}:`, error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid category data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to update category" });
      }
    }
  });

  app.delete("/api/categories/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteCategory(id);
      if (!success) {
        res.status(404).json({ error: "Category not found" });
        return;
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete category" });
    }
  });

  // Warehouses
  app.get("/api/warehouses", async (req, res) => {
    try {
      const warehouses = await storage.getWarehouses();
      res.json(warehouses);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch warehouses" });
    }
  });

  app.post("/api/warehouses", async (req, res) => {
    try {
      console.log("Received warehouse data:", req.body);
      const warehouseData = insertWarehouseSchema.parse(req.body);
      console.log("Parsed warehouse data:", warehouseData);
      const warehouse = await storage.createWarehouse(warehouseData);
      console.log("Created warehouse:", warehouse);
      res.status(201).json(warehouse);
    } catch (error) {
      console.error("Warehouse creation error:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid warehouse data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to create warehouse", details: error instanceof Error ? error.message : String(error) });
      }
    }
  });

  app.put("/api/warehouses/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const warehouseData = insertWarehouseSchema.partial().parse(req.body);
      const warehouse = await storage.updateWarehouse(id, warehouseData);
      if (warehouse) {
        res.json(warehouse);
      } else {
        res.status(404).json({ error: "Warehouse not found" });
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid warehouse data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to update warehouse" });
      }
    }
  });

  app.patch("/api/warehouses/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const warehouseData = insertWarehouseSchema.partial().parse(req.body);
      console.log("PATCH warehouse request for ID:", id, "with data:", warehouseData);
      const warehouse = await storage.updateWarehouse(id, warehouseData);
      if (warehouse) {
        console.log("Warehouse updated successfully:", warehouse);
        res.json(warehouse);
      } else {
        console.log("Warehouse not found for ID:", id);
        res.status(404).json({ error: "Warehouse not found" });
      }
    } catch (error) {
      console.error("PATCH warehouse error:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid warehouse data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to update warehouse" });
      }
    }
  });

  app.delete("/api/warehouses/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteWarehouse(id);
      if (!success) {
        res.status(404).json({ error: "Warehouse not found" });
        return;
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete warehouse" });
    }
  });

  // Products
  app.get("/api/products", async (req, res) => {
    try {
      const products = await storage.getProducts();
      res.json(products);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch products" });
    }
  });

  // Endpoint –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –∑–∞–º–æ–≤–ª–µ–Ω–∏—Ö —Ç–æ–≤–∞—Ä—ñ–≤ (–æ–ø–ª–∞—á–µ–Ω—ñ –∞–ª–µ –Ω–µ –≤—ñ–¥–≤–∞–Ω—Ç–∞–∂–µ–Ω—ñ)
  app.get("/api/products/ordered", async (req, res) => {
    try {
      const orderedProducts = await storage.getOrderedProducts();
      res.json(orderedProducts);
    } catch (error) {
      console.error("Error fetching ordered products:", error);
      res.status(500).json({ error: "Failed to fetch ordered products" });
    }
  });

  app.get("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const product = await storage.getProduct(id);
      if (!product) {
        return res.status(404).json({ error: "Product not found" });
      }
      res.json(product);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch product" });
    }
  });

  app.post("/api/products", async (req, res) => {
    try {
      const productData = insertProductSchema.parse(req.body);
      const product = await storage.createProduct(productData);
      res.status(201).json(product);
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid product data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to create product" });
      }
    }
  });

  app.put("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const productData = insertProductSchema.partial().parse(req.body);
      const product = await storage.updateProduct(id, productData);
      if (!product) {
        return res.status(404).json({ error: "Product not found" });
      }
      res.json(product);
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: "Invalid product data", details: error.errors });
      } else {
        res.status(500).json({ error: "Failed to update product" });
      }
    }
  });

  app.delete("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteProduct(id);
      if (!deleted) {
        return res.status(404).json({ error: "Product not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete product" });
    }
  });

  // –Ü–º–ø–æ—Ä—Ç —Ç–æ–≤–∞—Ä—ñ–≤ –∑ XML
  app.post('/api/products/import-xml', isSimpleAuthenticated, upload.single('file'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'XML —Ñ–∞–π–ª –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ' });
      }

      const result = await storage.importProductsFromXml(req.file.buffer);
      res.json({
        success: true,
        jobId: result.jobId,
        message: `–Ü–º–ø–æ—Ä—Ç —Ä–æ–∑–ø–æ—á–∞—Ç–æ, ID –∑–∞–≤–¥–∞–Ω–Ω—è: ${result.jobId}`
      });
    } catch (error) {
      console.error('Products XML import error:', error);
      res.status(500).json({ 
        success: false,
        error: '–ü–æ–º–∏–ª–∫–∞ —ñ–º–ø–æ—Ä—Ç—É —Ç–æ–≤–∞—Ä—ñ–≤ –∑ XML' 
      });
    }
  });

  // –°—Ç–∞—Ç—É—Å —ñ–º–ø–æ—Ä—Ç—É —Ç–æ–≤–∞—Ä—ñ–≤ –∑ XML
  app.get('/api/products/import-xml/:jobId/status', isSimpleAuthenticated, async (req, res) => {
    try {
      const { jobId } = req.params;
      const jobStatus = await storage.getProductImportJobStatus(jobId);
      
      if (!jobStatus) {
        return res.status(404).json({ 
          success: false,
          error: '–ó–∞–≤–¥–∞–Ω–Ω—è —ñ–º–ø–æ—Ä—Ç—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ' 
        });
      }

      res.json({
        success: true,
        job: jobStatus
      });
    } catch (error) {
      console.error('Error fetching import job status:', error);
      res.status(500).json({ 
        success: false,
        error: '–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–∞—Ç—É—Å—É —ñ–º–ø–æ—Ä—Ç—É' 
      });
    }
  });

  // Inventory
  app.get("/api/inventory", async (req, res) => {
    try {
      const inventory = await storage.getInventory();
      res.json(inventory);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch inventory" });
    }
  });

  app.get("/api/inventory/warehouse/:warehouseId", async (req, res) => {
    try {
      const warehouseId = parseInt(req.params.warehouseId);
      const inventory = await storage.getInv